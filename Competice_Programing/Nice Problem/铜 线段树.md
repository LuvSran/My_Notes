[Problem - E - Codeforces](https://codeforces.com/contest/2145/problem/E)
https://codeforces.com/contest/2145/problem/E记 `pre[x]` 数组为 `max(a[i]-ac,0)+max(d[i]-dr)<=x` 的数量。钦定当前答案为 `k` ,则有 `pre[k]=k` ,即 `pre[k]-k==0`，且`k`前缀的每一个位置 `i` 都有 `pre[i]>0` ,即`pre[i]-i>0`。则答案 `k` 为第一个 `pre[i]-i=0` 的位置 `i`,即 `pre[i]-i` 序列第一个前缀最小值`<=0`的位置`i` 。线段树维护 `pre[i]-i` 序列，利用区间最小值，线段树上二分找第一个`pre[i]-i==0` 的位置即为答案
```cpp
const int maxn=5*1e5+20;
const int maxV=2*1e6+20;
template <int N>struct Segment_tree{  
    #define ls (p<<1)
    #define rs ((p<<1)|1)
    struct{  
        int l,r;  
        int mn;
        int lz;
    }tr[4*N];  
    void push_up(int p){  
        tr[p].mn=min(tr[ls].mn,tr[rs].mn);
    }  
    void push_down(int p){
        if(tr[p].lz==0) return;
        int k=tr[p].lz;
        tr[p].lz=0;
        tr[ls].lz+=k,tr[ls].mn+=k;
        tr[rs].lz+=k,tr[rs].mn+=k;
    }
    void build(int p,int lo,int ro){  
        tr[p].l=lo,tr[p].r=ro;
        if(lo==ro){
            tr[p].mn=-lo;
            return;
        }  
        int mid=(lo+ro)>>1;  
        build(ls,lo,mid);  
        build(rs,mid+1,ro);  
        push_up(p);
    }  
    void Fix(int p,int lo,int ro,int k){    
        if(lo<=tr[p].l && ro>=tr[p].r){
            tr[p].mn+=k;
            tr[p].lz+=k;
            return;
        }
        push_down(p);
        if(lo<=tr[ls].r) Fix(ls,lo,ro,k);
        if(ro>=tr[rs].l) Fix(rs,lo,ro,k);
        push_up(p);
    }  
    int Find(int p){
        if(tr[p].l==tr[p].r) return tr[p].l;
        push_down(p);
        if(tr[ls].mn<=0) return Find(ls);
        return Find(rs);
    }
};
Segment_tree<maxV> T;
int a[maxn],b[maxn];
const int lim=2*1e6+1;
void solve(){
    int ac,dr;
    cin >> ac >> dr;
    int n;
    cin >> n;
    T.build(1,0,lim);
    for(int i=1;i<=n;++i) cin >> a[i];
    for(int i=1;i<=n;++i) cin >> b[i];
    for(int i=1;i<=n;++i) T.Fix(1,max(0,a[i]-ac)+max(0,b[i]-dr),lim,1);
    int q;
    cin >> q;
    while(q--){
        int x,nx,ny;
        cin >> x >> nx >> ny;
        T.Fix(1,max(0,a[x]-ac)+max(0,b[x]-dr),lim,-1);
        a[x]=nx,b[x]=ny;
        T.Fix(1,max(0,a[x]-ac)+max(0,b[x]-dr),lim,1);
        cout << T.Find(1) << '\n';
    }
}
```