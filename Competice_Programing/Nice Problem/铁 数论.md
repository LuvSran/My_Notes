[F - x = a^b](https://atcoder.jp/contests/abc361/tasks/abc361_f)
注意到当 a 在 $[\sqrt[3]n+1 , \sqrt[2]n]$ 之间时，只对答案有1的贡献。因此直接对答案加上 $\sqrt[2]n-\sqrt[3]n$ 。小于 $\sqrt[3]n$ 的部分，每个 a 最多对答案有 log 次贡献，$\sqrt[3]n<1e6$ , 直接暴力统计。计算 a 贡献时，为防止贡献记重，若  $\sqrt[2]{a^b}$  在$[\sqrt[3]n+1 , \sqrt[2]n]$ ，则贡献减 1 。并且若 a 唯一分解后，质因子指数的 `gcd()!=1` 时，说明 a 及其幂被之前更小的数统计过,直接跳过。
```cpp
SHAI<maxn> T; //线性筛
ll isqrt(ll _x){
    ll t=sqrtl(_x);
    while(t*t<_x) ++t;
    while(t*t>_x) --t;
    return t;
}
ll kg(ll _x){ //开三次方根
    ll l=1,r=1000000;
    while(l<r){
        i128 mid=(l+r+1)>>1;
        if(mid*mid*mid<=_x) l=mid;
        else r=mid-1;
    }
    return l;
}
void solve(){
    T.Run();
    ll n;
    cin >> n;
    ll lim_l=kg(n);
    ll lim_r=isqrt(n);
    ll ans=0;
    auto work=[&](ll x){
        ll g=0;
        ll _x=x;
        while(_x!=1){
            int t=T.Minp(_x); //求_x的最小质因子
            int cnt=0;
            while(_x%t==0){
                ++cnt;
                _x/=t;
            }
            g=gcd(g,cnt);
        }
        if(g!=1) return;
        i128 all=x;
        while(all*x<=n){
            all*=x;
            ++ans;
            ll sq=isqrt(all);
            if(sq*sq==all && sq>=lim_l+1 && sq<=lim_r) --ans;
        }
    };
    for(ll i=2;i<=lim_l;++i)  work(i);
    ans+=lim_r-lim_l;
    ans+=1; //1特判
    cout << ans;
}
```