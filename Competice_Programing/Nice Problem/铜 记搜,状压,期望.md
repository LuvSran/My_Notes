[E - Yacht](https://atcoder.jp/contests/abc421/tasks/abc421_e)

## Key
五个骰子，每个骰子6面，三回合。考虑记搜。`dp[S][k]`表示当前为第`k`回合，确定的骰子面为`S`状态下用最佳策略继续投的期望。`S`为十进制，`例如.1121`表示确定了四个骰子分别为第1,1,2,1面。由`S`位数长度确定还要投几个骰子，六进制枚举所有投掷情况。对于一种投掷情况，二进制枚举固定哪几个，并取期望最大。所有投掷情况最大期望求和除以总情况数即为`dp[S][k]`.
```cpp
using ldouble = long double;
const ldouble Y=1.0000000000;
ldouble dp[77777][5];
ldouble val[77777];
int bit[80000][7];
ll pw[10];
ll p_10[8]={1,10,100,1000,10000,100000,1000000};
int a[10];
ldouble dfs(int S,int len,int k){
    if(dp[S][k]>=0) return dp[S][k];
    if(k==0){
        dp[S][k]=val[S];
        return dp[S][k];
    }
    int sy=5-len;
    if(sy==0){
        dp[S][k]=dfs(S,len,k-1);
        return dp[S][k];
    }
    int lim=pw[sy]-1;
    dp[S][k]=0.00000;
    for(int i=0;i<=lim;++i){
        ldouble res=0;
        if(k==1){
            int ts=S,tlen=len;
            for(int j=0;j<=sy-1;++j) tlen+=1,ts+=(bit[i][j]+1)*p_10[tlen-1];
            res=dfs(ts,tlen,k-1);
        }
        else{
            for(int bl=0;bl<=(1<<sy)-1;++bl){
                ll ts=S,tlen=len;
                for(int j=0;j<=sy-1;++j){
                    if(Bit(bl,j)==1) ++tlen,ts+=(bit[i][j]+1)*p_10[tlen-1];
                }
                res=max(res,dfs(ts,tlen,k-1));
            }
        }
        dp[S][k]+=res;
    }
    dp[S][k]=dp[S][k]/(Y*pw[sy]);
    return dp[S][k];
}
void solve(){
    for(int i=1;i<=6;++i) cin >> a[i];
    for(int i=0;i<=66666;++i) for(int j=0;j<=3;++j) dp[i][j]=-1;
    for(int i=0;i<=66666;++i){
        vector<int> t;
        int ss=i;
        while(ss) t.pb(ss%10),ss/=10;
        for(int _x:t){
            ldouble sum=0;
            for(int _y:t) if(a[_y]==a[_x]) sum+=a[_x];
            val[i]=max(val[i],sum);
        }
    }
    pw[0]=1;
    for(int i=1;i<=8;++i) pw[i]=pw[i-1]*6ll;
    for(int i=0;i<8000;++i){
        int t=i;
        for(int j=0;j<=4;++j) bit[i][j]=t%6,t/=6;
    }
    ldouble ans=dfs(0,0,3);
    printf("%.9Lf",ans);
}
```