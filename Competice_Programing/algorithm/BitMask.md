```cpp
#define Bit(_i,_j) ((_i>>_j)&1) //求i的第j位
#define Set_1(_i,_j) (_i|(1ll<<_j)) //将i的第j位设为1
#define Set_0(_i,_j) (_i&(~(1ll<<_j))) //将i的第j位设为0
#define Rev(_i,_j) (_i^(1ll<<_j)) //将i的第j位取反
```

# 函数 
`__builtin_popcountll(n)`：返回n的64位二进制中有几个1
`__builtin_clzll(n)`:返回n的64位二进制中前导零个数
`__builtin_ctzll(n)`:n的64位二进制中后缀零个数
求32位则去掉末尾ll
------
# 求n的二进制表示中第k位(从右往左0开始计数)是几
 ## ==n>>k&1==
 ---
# lowbit(x)(返回x的最后一位1)
## eg.  
lowbit(1010)=10
lowbit(101000)=1000
## ==x&-x==
因为x&-x=x&(~x+1)
# XOR
异或，同0不同1
*xor满足结合率*,即` a^b^c^d=(a^b)^(c^d)`
*xor的逆运算是xor*，若有三个部分`a^b=c`，则任意两个部分xor等于另一个部分，即`a^b=c,a^c=b,c^a=b,c^b=2`
*相等的两个数xor等于0*，`a^a=0`
*0和任何数xor等于那个数*，`0^a=a`
*x^y结果在[x-y,x+y]范围内(x>y)*
`11111..1`=`10000...0`\*2-1;
*eg.* `4=100` ,`7=111`; `16=10000`,`31=11111`

 