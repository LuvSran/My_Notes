1. 一个序列，有某位置`pos`，`pos`前所有目标元素有cnt个，到`pos`的距离之和为sumlen，则`pos`往后移一位，距离和更新为原距离和+元素个数。即`sumlen+=cnt`(应先判断`cnt`是否要+1，更新`cnt`后再更新`sumlen`),即位置pos之前cnt个目标元素坐标idx到pos的距离和∑<sub>i=1</sub><sup>cnt</sup>(pos-$idx_i$) =∑<sub>i=1</sub><sup>cnt</sup>(pos-$idx_i$) +cnt;
2. 一个`1~n`的排列`p` ,按`p[i]=>p[p[i]]`走，为若干个环或点；若某个环内所有点$p_i$同时变为$p_{p_i}$，进行`k`次变换，则环内每个点变为在环内向后跳$2^k$个点所到达的点
3. 在`n*n`的平面坐标系内，点`(x1,y1),(x2,y2)`组成的直线覆盖的所有点为
```
int dx=x2-x1,dy=y2-y1;
int g=gcd(abs(dx),abs(dy));
dx/=g,dy/=g
for(int k=0;x1+k*dx<=n && x1+k*dx>=1 && y1+k*dy<=n && y1+k*dy>=1;++k)
                vis[x1+k*dx][y1+k*dy]=true;
for(int k=0;x1+k*dx<=n && x1+k*dx>=1 && y1+k*dy<=n && y1+k*dy>=1;--k)
               vis[x1+k*dx][y1+k*dy]=true; 
```
4. 对于数字 `x` 和 `y`  , `x` 和 `y` 每一位上的数字都是 `1` .其中 `x` 的长度为 `len1` ， `y` 的长度为 `len2` 。若 `len2` 为 `len1` 的倍数，则 `y` 为 `x` 的倍数。即长度为 `len` 的一连串的数是 `d` 的倍数，那么长度为 `n*len` 的一连串数也一定是 `d` 的倍数。
 5. $a_n=n^2,则S_n=n(n+1)(2n+1)/6$
 6. 点`( x1,y1 ),( x2,y2 )`的曼哈顿距离,等于点` ( x1+y1,x1-y1),( x2+y2,x2-y2 )`的切比雪夫距离。切比雪夫转曼哈顿则为`( x,y ) => ( (x+y)/2,(x-y)/2 )`
 
7. 判断子集和是否存在dp，bitset优化，$n^2 => n^2/64$
```
//原
vector<bool> dp(maxn,false);
dp[0]=true;
    for(int x:a){    //a为vector
        for(int i=n;i>=x;--i){
            if(dp[i-x]==true) dp[i]=true;
        }
    }
 //bitset优化
 bitset<maxn> dp;
 dp[0]=1;
 for(int x:a){
        dp|=dp<<x;
 }
 if(dp[n]==1) cout << "YES\n";
```
8. 网格图中，对于起点横坐标`st`,终点横坐标`ed`，终点相对于起点向左偏移量`l`，向右偏移量`r`,有`l-r=st-ed`
9. 深度(根节点为0)为d的满k叉树，节点数T为$$T=\frac{k^{d+1}-1 }{k-1}$$
10. 树中任意点u的最远距离的另一端点v，一定是树的直径的某一端点
11. 连续的4个数异或，或两两相距为4的4个数异或，结果为0。`eg: 8^9^10^11=0. 8^12^16^20=0`
12. x,y,z是正整数，如果`ceil(x,y)<=z`，那么`ceil(x,z)<=y`。如果`x/y<=z`，那么 `y>=x/(z+1)+1`
13. 质因子分解后$$ X=p_1^{k1}*p_2^{k2}*p_3^{k3}*....*p_n^{kn}$$，则$X$ 的因数(含1和X)数量为$(k_1+1)*(k_2+1)*(k_3+1)*....*(k_n+1)$
14. 0开始的数，二进制第`j`位是$2^j$个0，$2^j$个1，$2^j$个0，$2^j$个1...依次出现
```
0：000
1：001
2：010
3：011
4：100
5：101
6：110
7：111
```
 15. 有n个元素，每个元素x每一次变化可以变化为x-1或变化为x+1,要将这n个元素变为相同，那么将每个元素变为中位数，变化次数最少
 16. 若2和3不限次数，则可用2和3组合成任何数
 17. `a[1],a[2]...a[n]`为原数组，差分数组`d[1]=a[1],d[2]=a[2]-a[1],...,d[n]=a[n]-a[n-1]`，则`gcd(a[l]~a[r])=gcd(a[i],d[l+1]~d[r])`,其`i`为任意的满足`l<=i<=r` 。且`gcd(a[l]~a[r])∣GCD(d[l+1],…,d[r])`
 18. 启发式合并：若干个集合，集合元素总数为`N`，需要最终合并为一个集合，若将集合v合并到集合u的复杂度为`|v|`,则每次将小的集合合并到大的上，复杂度为`O(NlogN)`